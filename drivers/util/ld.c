/*
 * Copyright (C) 2014 Stefan Demharter <stefan.demharter@gmx.net>
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 */

#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/module.h>

/* round(ln(x) / ln(2) * 2^16) for x in range(1, 257) */
static const uint32_t ld[] = {
	UINT_MAX,
	    0x0, 0x10000, 0x195c0, 0x20000, 0x2526a, 0x295c0, 0x2ceaf, 0x30000,
	0x32b80, 0x3526a, 0x3759d, 0x395c0, 0x3b350, 0x3ceaf, 0x3e82a, 0x40000,
	0x41664, 0x42b80, 0x43f78, 0x4526a, 0x4646f, 0x4759d, 0x48608, 0x495c0,
	0x4a4d4, 0x4b350, 0x4c140, 0x4ceaf, 0x4dba5, 0x4e82a, 0x4f446, 0x50000,
	0x50b5d, 0x51664, 0x52119, 0x52b80, 0x5359f, 0x53f78, 0x54910, 0x5526a,
	0x55b89, 0x5646f, 0x56d20, 0x5759d, 0x57dea, 0x58608, 0x58dfa, 0x595c0,
	0x59d5e, 0x5a4d4, 0x5ac24, 0x5b350, 0x5ba59, 0x5c140, 0x5c807, 0x5ceaf,
	0x5d538, 0x5dba5, 0x5e1f5, 0x5e82a, 0x5ee45, 0x5f446, 0x5fa2f, 0x60000,
	0x605ba, 0x60b5d, 0x610eb, 0x61664, 0x61bc8, 0x62119, 0x62656, 0x62b80,
	0x63098, 0x6359f, 0x63a94, 0x63f78, 0x6444c, 0x64910, 0x64dc5, 0x6526a,
	0x65700, 0x65b89, 0x66003, 0x6646f, 0x668ce, 0x66d20, 0x67165, 0x6759d,
	0x679ca, 0x67dea, 0x681ff, 0x68608, 0x68a06, 0x68dfa, 0x691e2, 0x695c0,
	0x69994, 0x69d5e, 0x6a11e, 0x6a4d4, 0x6a881, 0x6ac24, 0x6afbe, 0x6b350,
	0x6b6d9, 0x6ba59, 0x6bdd1, 0x6c140, 0x6c4a8, 0x6c807, 0x6cb5f, 0x6ceaf,
	0x6d1f7, 0x6d538, 0x6d872, 0x6dba5, 0x6ded0, 0x6e1f5, 0x6e513, 0x6e82a,
	0x6eb3b, 0x6ee45, 0x6f149, 0x6f446, 0x6f73e, 0x6fa2f, 0x6fd1a, 0x70000,
	0x702e0, 0x705ba, 0x7088e, 0x70b5d, 0x70e27, 0x710eb, 0x713aa, 0x71664,
	0x71919, 0x71bc8, 0x71e73, 0x72119, 0x723ba, 0x72656, 0x728ed, 0x72b80,
	0x72e0f, 0x73098, 0x7331e, 0x7359f, 0x7381b, 0x73a94, 0x73d08, 0x73f78,
	0x741e4, 0x7444c, 0x746b0, 0x74910, 0x74b6c, 0x74dc5, 0x75019, 0x7526a,
	0x754b7, 0x75700, 0x75946, 0x75b89, 0x75dc7, 0x76003, 0x7623a, 0x7646f,
	0x766a0, 0x768ce, 0x76af8, 0x76d20, 0x76f44, 0x77165, 0x77383, 0x7759d,
	0x777b5, 0x779ca, 0x77bdb, 0x77dea, 0x77ff6, 0x781ff, 0x78405, 0x78608,
	0x78809, 0x78a06, 0x78c01, 0x78dfa, 0x78fef, 0x791e2, 0x793d2, 0x795c0,
	0x797ab, 0x79994, 0x79b7a, 0x79d5e, 0x79f3f, 0x7a11e, 0x7a2fa, 0x7a4d4,
	0x7a6ab, 0x7a881, 0x7aa53, 0x7ac24, 0x7adf2, 0x7afbe, 0x7b188, 0x7b350,
	0x7b515, 0x7b6d9, 0x7b89a, 0x7ba59, 0x7bc16, 0x7bdd1, 0x7bf8a, 0x7c140,
	0x7c2f5, 0x7c4a8, 0x7c658, 0x7c807, 0x7c9b4, 0x7cb5f, 0x7cd08, 0x7ceaf,
	0x7d054, 0x7d1f7, 0x7d399, 0x7d538, 0x7d6d6, 0x7d872, 0x7da0c, 0x7dba5,
	0x7dd3b, 0x7ded0, 0x7e063, 0x7e1f5, 0x7e385, 0x7e513, 0x7e69f, 0x7e82a,
	0x7e9b3, 0x7eb3b, 0x7ecc1, 0x7ee45, 0x7efc8, 0x7f149, 0x7f2c8, 0x7f446,
	0x7f5c3, 0x7f73e, 0x7f8b7, 0x7fa2f, 0x7fba5, 0x7fd1a, 0x7fe8e, 0x80000,
	UINT_MAX, /* sentinel element */
};

uint32_t util_ld(uint32_t val)
{
	if (val < ARRAY_SIZE(ld))
		return ld[val];

	return UINT_MAX;
}
EXPORT_SYMBOL_GPL(util_ld);

/*
 * ceil(2^(ld_val / 2^16)), i.e.
 * find smallest idx with ld_val <= ld[idx]
 * valid for 0 <= ld_val <= last_ld_element
 */
uint32_t util_ceil_pow_2(uint32_t ld_val)
{
	size_t start = 1;
	size_t end = ARRAY_SIZE(ld) - 2;
	size_t mid;

	while (start <= end) {
		uint32_t ld_mid;
		mid = (start + end) / 2;
		ld_mid = ld[mid];
		if (ld_val <= ld_mid)
			end = mid - 1;
		else
			start = mid + 1;
	}

	return end + 1;
}
EXPORT_SYMBOL_GPL(util_ceil_pow_2);

/*
 * Fill the vals from min to max in an exponential way and
 * respect the offset, i.e.
 * vals[i] = (min + off) * ((max + off) / (min + off)) ^ (i / 15) - off
 */
void util_fill_exp(uint32_t *vals, size_t size, uint32_t off, uint32_t min, uint32_t max)
{
	uint32_t o = off;
	uint32_t l = min;
	uint32_t u = max;
	uint32_t i = 0;

	for (; i < size; ++i) {
		uint32_t ld_val = util_ld(l + o) +
			DIV_ROUND_CLOSEST(i * (util_ld(u + o) - util_ld(l + o)), size - 1);
		uint32_t val_o = util_ceil_pow_2(ld_val);

		vals[i] = val_o - o;
	}
}
EXPORT_SYMBOL_GPL(util_fill_exp);
